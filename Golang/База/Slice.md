## Способы объявления

```go
var foo []string                  // 1
foo2 := []byte{}                  // 2
foo3 := []int{2, 3, 5, 7, 11, 13} // 3
var foo3 []int = array[1:4]       // 4
foo4 := array[1:4]                // 4
foo5 := make([]int, 5, 5)          // 5
foo6 := make([]string, 5)          // 6
```
- **1** -  без инициализации
- **2** - shorthand без инициализации
- **3** - c инициализацией
- **4** - срез [[Array|массива]]
- **5** - `make` с длиной и [[Slice#Вместимость и длина|вместимостью]]
- **6** - `make` с длиной (=[[Slice#Вместимость и длина|вместимость]])
- **Формат** с `make` - `make([]тип данных, длина, вместимость)`

## Заполнение

```go
s1 = make([]byte, 5)
sl[0] = 1

sl = append(sl, 2)

fmt.Printf("%T", s1) // []int
```
 - Тип слайса определяется его [[Типы данных|типом данных]]
 - **Дефолтные значения элементов** без инициализации - nil
 - **Дефолтные значения элементов** при задании ненулевой длины - 0

## Копирование

``` go
nameSlice := [6]string{"D", "a", "n", "i", "i", "l"}	
secondNameSlice := make([]string, len(nameSlice), cap(nameSlice))	

copy(secondNameSlice, nameSlice)
```
- Если инициализировать слайс через срез [[Array|массива]], то при изменении слайса, изменится и [[Array|массив]]
- `copy(slice, array)` - создать независимую копию [[Array|массива]]


## Вместимость и длина

```go
cap(s)

len(s)
```
- **Длина слайса - динамическая
- `len()` - длина слайса
- **Вместимость** - сколько памяти нужно выделить заранее под массив, чтобы при расширении нам не пришлось искать новый участок памяти
- Если не задать вместимость, то она будет равна длине
- Вместимость не может быть меньше длины
- При переполнении вместимости она увеличивается в 2 раза
-  Если вместимость переполнена и следующие ячейки памяти заняты, то Go скопирует слайс в другое место, где ячеек хватает
- `cap()` - вместимость слайса

## Срезы

```go
a[2:10] // 1
a[:10]  // 2
a[0:]   // 3
a[:]    // 4
```
- **1** - со 2 элемента до 10
- **2** - с 0 элемента до 10
- **3** - с 0 до конца
- **4** - с начала до конца
